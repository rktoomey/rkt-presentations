!SLIDE

# Given - When - Then

In specs 1.x, ``given``, ``when`` and ``then`` were methods with no added value but displaying these words with a
description.

In specs2, ``Given``, ``When`` and ``Then`` are now ``RegexSteps`` that can extract typed values from parameterized text:

    class GivenWhenThenSpec extends org.specs2.Specification { def is =
      "A given-when-then example for GCD"                   ^
        "Given the following number: ${4}"                  ^ number1 ^
        "And the following number: ${2}"                    ^ number2 ^
        "Then the greatest common denominator is ${2}"      ^ result ^
                                                            end
      object number1 extends Given[Long] {
        def extract(text: String): Long = extract1(text).toLong
      }
      object number2 extends When[Long, BinaryGCD] {
        def extract(number1: Long, text: String) =
          BinaryGCD(number1, extract1(text).toLong)
      }
      object result extends Then[BinaryGCD] {
        def extract(b: BinaryGCD, text: String): Result =
          b.gcd must_== extract1(text).toLong
      }
      case class BinaryGCD(u: Long, v: Long) {
        def gcd: Long = { /* Some impl */ }
      }
    }

!SLIDE

# Using ScalaCheck to reduce drudgery

For all the ceremony in the previous ``GivenWhenThenSpec``, it's dreadful:

- it tests only a single case
- we have to supply all the inputs and expectations by hand.  *Yawn.*
- how long would it take us to cover a halfway decent set of data?
<br/>
<br/>

Generating test case data by hand is a drag.  [ScalaCheck](http://code.google.com/p/scalacheck/) to the rescue!

## Key concepts

- a property is a _testable unit_ that specifies the behaviour of a method
    - properties created from functions require an implciit ``Arbitrary[T]`` instance
- generators are responsible for generating data in ScalaCheck
<br/>
<br/>

Consult the [ScalaCheck User Guide](http://code.google.com/p/scalacheck/wiki/UserGuide) for a detailed explanation
of property and generator types.

!SLIDE

# specs2 support for ScalaCheck

specs2 comes with built-in support for [ScalaCheck](http://code.google.com/p/scalacheck/wiki/UserGuide).

- extend ``org.specs2.Specification`` with ``org.specs2.ScalaCheck``
  - the ``ScalaCheck`` trait provides a ``check`` function that transforms a function to
  a ``org.scalacheck.Prop`` and then to a ``Result``
- import step classes (``Given``, ``When``, etc) from ``org.specs2.specification.gen`` instead of ``org.specs2.specification``
  - ``Given`` and ``When`` steps now return ScalaCheck generators
  - the ``extract`` method on ``Then`` takes an implicit ``Arbitrary[T]``

## More examples

See [JsonSpec](https://github.com/etorreborre/specs2/blob/master/src/test/scala/org/specs2/json/JsonSpec.scala) for
an example of using ScalaCheck to generate JSON.

!SLIDE

# Using ScalaCheck

    class ScalaCheckGwtSpec extends Specification with ScalaCheck { def is =
        "Testing Binary GCD calculator"                     ^
          "Given the following number n1"                   ^ number1 ^
          "And the following number n2"                     ^ number2 ^
          "When we take the greatest common denominator"    ^ gcd ^
          "Then the binary GCD matches the Euclidian GCS"   ^ result ^
                                                            end
      object number1 extends Given[Long] {
        def extract(text: String) = choose(-10L, 10L)
      }
      object number2 extends When[Long, (Long, Long)] {
        def extract(number1: Long, text: String) =
          for { n2 <- choose(-10L, 10L) } yield (number1, n2)
      }
      object gcd extends When[(Long, Long), BinaryGCD] {
        def extract(numbers: (Long, Long), text: String) =
          BinaryGCD(numbers._1, numbers._2)
      }
      object result extends Then[BinaryGCD] {
        def extract(text: String)(implicit op: Arbitrary[BinaryGCD]) = {
          check { (op: BinaryGCD) => op.gcd must_== EuclidianGCD(op.u, op.v) }
        }
      }
    }

!SLIDE

# Running ScalaCheck

Using all the permutations of data generated by ``choose``, we make the anemic ``GivenWhenThenSpec``
far more robust by running our expectation **100** times and checking our Binary GCD algorithm against
the results of an indepdendent Euclidian GCD algorithm.

    [info] == prasinous.acceptance.ScalaCheckGwtSpec ==
    [info] Testing Binary GCD calculator
    [info] Given the following number n1
    [info] And the following number n2
    [info] When we take the greatest common denominator
    [info] + Then the binary GCD matches the Euclidian GCS
    [info]
    [info] Total for specification ScalaCheckGwtSpec
    [info] Finished in 59 ms
    [info] 1 example, 100 expectations, 0 failure, 0 error
    [info]
    [info] == prasinous.acceptance.ScalaCheckGwtSpec ==

And if we decide to run the expectation **10,000** times, all we have to do is change some inputs to ``choose``.

!SLIDE

# Could you use Given - When - Then with unit specs?

<span class="eric"><b>Eric:</b> I'm not actually sure how feasible this is actually because the GivenWhenThen steps in an
Acceptance spec are very typechecked. In a mutable spec I would need to do runtime checks and have additional
variables.</span>

If there _were_ suport for it, Eric suggests it might look like this:

    class ScalaCheckGwtUnitSpec extends Specification with ScalaCheck {
      "Testing Binary GCD calculator" {
        "Given the following number n1" ! given[Long] {
          def extract(text: String) = choose(-10L, 10L)
        }
        "And the following number n2" ! when[Long, (Long, Long)] {
          def extract(number1: Long, text: String) = for {n2 <- choose(-10L, 10L)} yield (number1, n2)
        }
        "When we take the greatest common denominator" ! when[(Long, Long), BinaryGCD] {
          def extract(numbers: (Long, Long), text: String) = BinaryGCD(numbers._1, numbers._2)
        }
        "Then the binary GCD matches the Euclidian GCS " ! then[BinaryGCD] {
          def extract(text: String)(implicit op: Arbitrary[BinaryGCD]) =
            check {
              (op: BinaryGCD) => op.gcd must_== EuclidianGCD(op.u, op.v)
            }
        }
      }
    }

<img class="logo" src="/img/novus-logo.gif" />